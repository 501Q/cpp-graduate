//-----------------------------------------------------------------------------
//
// Source code for MIPT ILab
// Slides: https://sourceforge.net/projects/cpp-lects-rus/files/cpp-graduate/
// Licensed after GNU GPL v3
//
//------------------------------------------------------------------------------
//
// Tests for permutation loops
//
//------------------------------------------------------------------------------

#include <iostream>
#include <iterator>
#include <vector>

#include "groups.hpp"
#include "idomain.hpp"
#include "permloops.hpp"
#include "perms.hpp"

// permutation loops application:
// (1, 2) applied to [1, 2, 3, 4] yields [2, 1, 3, 4]
// (1, 2, 3) applied to [1, 2, 3, 4] yields [2, 3, 1, 4]
void test_permloop() {
  using UD4 = UnsignedDomain<1, 4>;
  std::ostream_iterator<UD4> Os(std::cout, " ");
  auto Init = UD4::iota();
  std::cout << "Initial sequence:" << std::endl;
  std::copy(Init.begin(), Init.end(), Os);
  std::cout << std::endl;

  PermLoop<UD4> PL = {4, 2, 1, 3};
  PL.apply(Init.begin(), Init.end());
  std::cout << PL << " applied: " << std::endl;
  std::copy(Init.begin(), Init.end(), Os);
  std::cout << std::endl;

  PermLoop<UD4> PL42 = {4, 2};
  PermLoop<UD4> PL13 = {1, 3};
  Init = UD4::iota();
  PL42.apply(Init.begin(), Init.end());
  PL13.apply(Init.begin(), Init.end());
  std::cout << "(4, 2) * (1, 3) applied: " << std::endl;
  std::copy(Init.begin(), Init.end(), Os);
  std::cout << std::endl;
}

// simplification in ctor of permutation
void test_simple_perm() {
  using UD9 = UnsignedDomain<1, 9>;
  std::vector<UD9> Init = {9, 2, 3, 1, 7, 6, 8, 5, 4};
  std::vector<PermLoop<UD9>> Permloops;
  create_loops(Init.begin(), Init.end(), std::back_inserter(Permloops));
  Permutation<UD9> P(Permloops.begin(), Permloops.end());
  std::cout << "[9, 2, 3, 1, 7, 6, 8, 5, 4] simplified to: " << P << std::endl;
}

// simplification in ctor of permutation, another approach
void test_perm_mult() {
  using UD4 = UnsignedDomain<1, 4>;
  Permutation<UD4> P = {{1, 3, 2}, {1, 2, 4}, {1, 4, 3, 2}};
  std::cout << "(1 3 2)(1 2 4)(1 4 3 2) simplified to: " << P << std::endl;
}

// every permutation can be generated by cyclic permutation like (1, 2, 3, 4)
// and (1, 2) so for any element we shall see orbit of all elements
void test_simple_group() {
  using UD4 = UnsignedDomain<1, 4>;
  std::ostream_iterator<UD4> Os(std::cout, " ");
  UD4 Elt = 3;
  auto Init = UD4::iota();
  PermLoop<UD4> Cyclic(Init.begin(), Init.end());
  std::vector<Permutation<UD4>> SGens{{Cyclic}, {{1, 2}}};
  auto Orb = orbit(Elt, SGens.begin(), SGens.end());
  std::cout << "Orbit of element 3: ";
  std::copy(Orb.begin(), Orb.end(), Os);
  std::cout << std::endl;
}

// orbit with representatives is orbit for which we do know perm for any element
void test_reps_group() {
  using UD4 = UnsignedDomain<1, 4>;
  std::ostream_iterator<UD4> Os(std::cout, " ");
  UD4 Elt = 3;
  auto Init = UD4::iota();
  PermLoop<UD4> Cyclic(Init.begin(), Init.end());
  std::vector<Permutation<UD4>> SGens{{Cyclic}, {{1, 2}}};
  auto Orb = orbit_reps(Elt, SGens.begin(), SGens.end());
  std::cout << "Orbit of element 3 with representatives: " << std::endl;
  for (auto &&Nxt : Orb)
    std::cout << Nxt.first << ": " << Nxt.second << std::endl;
}

int main() {
  test_permloop();
  test_simple_perm();
  test_perm_mult();
  test_simple_group();
  test_reps_group();
}